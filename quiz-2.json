[
  {
    "번호": 1,
    "문제": "요구공학(Requirements Engineering)에 대한 설명으로 옳지 않은 것은?",
    "선택지": {
      "①": "무엇을 개발해야 하는지 요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문이다.",
      "②": "사용자 요구사항이 더욱 복잡해지고 잦은 변경이 발생하자 이를 적절하게 관리하기 위해 등장하였다.",
      "③": "요구사항 개발의 한 요소이다.",
      "④": "품질 개선과 프로젝트 실패의 최소화를 목적으로 한다."
    },
    "정답": "③",
    "해설": "요구공학은 요구사항 개발보다 더 큰 범주에 해당하므로 요구사항 개발이 요구공학의 한 요소가 됩니다."
  },
  {
    "번호": 2,
    "문제": "XP(eXtreme Programming)에 대한 설명으로 옳지 않은 것은?",
    "선택지": {
      "①": "릴리즈 기간을 짧게 반복하여 고객의 요구 변화에 빠르게 대응한다.",
      "②": "코드들은 하나의 작업이 마무리될 때마다 지속적으로 통합한다.",
      "③": "테스트가 지속적으로 진행될 수 있도록 테스트 자동화 도구를 사용한다.",
      "④": "개발 책임자가 모든 책임을 가지므로 팀원들은 책임 없이 자유로운 개발이 가능하다."
    },
    "정답": "④",
    "해설": "XP는 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성합니다."
  },
  {
    "번호": 3,
    "문제": "UML에서 활용되는 다이어그램의 이름과 설명의 연결이 올바르지 않은 것은?",
    "선택지": {
      "①": "클래스 다이어그램 : 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하는데, 메시지뿐만 아니라 객체들 간의 연관까지 표현한다.",
      "②": "배치 다이어그램 : 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현한다.",
      "③": "유스케이스 다이어그램 : 사용자의 요구를 분석하는 것으로, 기능 모델링 작업에 사용한다.",
      "④": "활동 다이어그램 : 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현한다."
    },
    "정답": "①",
    "해설": "클래스 다이어그램은 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현하는 다이어그램입니다. ①번은 커뮤니케이션 다이어그램에 대한 설명입니다."
  },
  {
    "번호": 4,
    "문제": "다음 설명에 해당하는 도표는? \n\n시스템의 기능을 여러 개의 고유 모듈들로 분할하여 이들 간의 인터페이스를 계층 구조로 표현한 것으로, 가시적 도표(Visual Table of Contents), 총체적 도표(Overview Diagram), 세부적 도표(Detail Diagram)가 있다.",
    "선택지": {
      "①": "Flow Chart",
      "②": "Burn-down Chart",
      "③": "Visual Diagram",
      "④": "HIPO Chart"
    },
    "정답": "④",
    "해설": "문제의 지문은 HIPO 차트에 대한 설명입니다."
  },
  {
    "번호": 5,
    "문제": "불필요한 메모리의 낭비를 최소화하기 위해 여러 프로세스가 동시에 참조할 수는 없지만 어디서든 참조할 수 있는 객체를 생성하는 디자인 패턴은?",
    "선택지": {
      "①": "싱글톤(Singleton) 패턴",
      "②": "옵서버(Observer) 패턴",
      "③": "프로토타입(Prototype) 패턴",
      "④": "상태(State) 패턴"
    },
    "정답": "①",
    "해설": "여러 프로세스가 동시에 참조할 수는 없지만 어디서든 참조할 수 있는 객체를 생성하는 디자인 패턴은 싱글톤(Singleton)입니다."
  },
  {
    "번호": 6,
    "문제": "객체지향 기법에서 객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산을 정의한 것은?",
    "선택지": {
      "①": "Entity",
      "②": "Method",
      "③": "Instance",
      "④": "Class"
    },
    "정답": "②",
    "해설": "객체지향 기법에서 객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산을 정의한 것을 메소드(Method)라고 합니다."
  },
  {
    "번호": 7,
    "문제": "바람직한 소프트웨어 설계 지침이 아닌 것은?",
    "선택지": {
      "①": "결합도를 최소화하고 응집도를 최대화한다.",
      "②": "복잡도와 중복성을 줄이고 일관성을 유지시킨다.",
      "③": "하나의 입구와 하나의 출구를 갖도록 해야 한다.",
      "④": "모듈의 크기를 가능한 작게 구성하여 병행성 수준을 높여야 한다."
    },
    "정답": "④",
    "해설": "모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해해야 합니다."
  },
  {
    "번호": 8,
    "문제": "객체지향 설계 원칙에 대한 설명 중 틀린 것은?",
    "선택지": {
      "①": "OCP : 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙",
      "②": "LSP : 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙",
      "③": "DIP : 각 객체들 간의 의존 관계가 성립될 때, 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙",
      "④": "ISP : 객체는 단 하나의 책임만 가져야 한다는 원칙"
    },
    "정답": "④",
    "해설": "인터페이스 분리 원칙(ISP)은 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙입니다. ④번은 단일 책임 원칙(SRP)에 대한 설명입니다."
  },
  {
    "번호": 9,
    "문제": "객체지향 분석 방법론 중 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 분석 방법으로, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의하는 것은?",
    "선택지": {
      "①": "Coad와 Yourdon 방법",
      "②": "Booch 방법",
      "③": "Jacobson 방법",
      "④": "Wirfs-Brocks 방법"
    },
    "정답": "②",
    "해설": "미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용하는 객체지향 분석 방법은 Booch(부치)입니다."
  },
  {
    "번호": 10,
    "문제": "HIPO Chart에 대한 설명으로 틀린 것은?",
    "선택지": {
      "①": "HIPO 차트 종류에는 가시적 도표, 총체적 도표, 세부적 도표가 있다.",
      "②": "충분한 사전 지식과 학습이 없으면 이해하기 어렵다.",
      "③": "기능과 자료의 의존 관계를 동시에 표현할 수 있다.",
      "④": "하향식 소프트웨어 개발을 위한 문서화 도구이다."
    },
    "정답": "②",
    "해설": "HIPO(Hierarchy Input Process Output)는 시스템의 분석 및 설계나 문서화할 때 사용되는 기법으로, 기호나 도표 등을 사용하므로 보기 쉽고 이해하기도 쉽다는 특징이 있습니다."
  },
  {
    "번호": 11,
    "문제": "코드 설계에서 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방식의 코드는?",
    "선택지": {
      "①": "연상 코드",
      "②": "블록 코드",
      "③": "순차 코드",
      "④": "표의 숫자 코드"
    },
    "정답": "④",
    "해설": "표의 숫자 코드(Significant Digit Code)는 코드화 대상 항목의 성질을 그대로 코드에 적용시키는 방법입니다."
  },
  {
    "번호": 12,
    "문제": "애자일 소프트웨어 개발 기법의 가치가 아닌 것은?",
    "선택지": {
      "①": "계획을 따르기보다는 변화에 대응하는 것에 더 가치를 둔다.",
      "②": "실제 작동하는 소프트웨어보다는 이해하기 좋은 문서에 더 가치를 둔다.",
      "③": "계약 협상보다는 고객과의 협업에 더 가치를 둔다.",
      "④": "프로세스의 도구보다는 개인과 상호작용에 더 가치를 둔다."
    },
    "정답": "②",
    "해설": "애자일(Agile)은 방대한 문서보다는 실행되는 SW에 더 가치 를 둡니다."
  },
  {
    "번호": 13,
    "문제": "Rayleigh-Norden 곡선의 노력 분포도를 이용한 프로젝트 비용 산정 기법은?",
    "선택지": {
      "①": "Putnam 모형",
      "②": "델파이 모형",
      "③": "COCOMO 모형",
      "④": "기능점수 모형"
    },
    "정답": "①",
    "해설": "문제에서 설명하는 내용은 Putnam 모형입니다."
  },
  {
    "번호": 14,
    "문제": "객체지향의 주요 개념에 대한 설명으로 틀린 것은?",
    "선택지": {
      "①": "상속은 상위 클래스에서 속성이나 연산을 전달받아 새로운 형태의 클래스로 확장하여 사용하는 것을 의미한다.",
      "②": "객체는 실세계에 존재하거나 생각할 수 있는 것을 말한다.",
      "③": "캡슐화는 두 개 이상의 객체(클래스)들이 상호 참조하는 관계이다.",
      "④": "다형성은 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질이다."
    },
    "정답": "③",
    "해설": "캡슐화는 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶어 인터페이스를 제외한 세부 내용을 은폐(정보 은닉)함으로써 외부에서의 접근을 제한하는 것입니다. 두 개 이상의 객체(클래스)들이 상호 참조하는 관계는 연관성입니다."
  },
  {
    "번호": 15,
    "문제": "웹 애플리케이션 서버(WAS; Web Application Server)에 대한 설명으로 틀린 것은?",
    "선택지": {
      "①": "정적인 콘텐츠를 처리하기 위해 사용되는 미들웨어이다.",
      "②": "클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어이다.",
      "③": "미션-크리티컬한 기업 업무도 JAVA, EJB 컴포넌트 기반으로 구현이 가능하다.",
      "④": "대표적인 WAS의 종류에는 오라클의 WebLogic, IBM의 WebSphere 등이 있다."
    },
    "정답": "①",
    "해설": "웹 애플리케이션 서버(WAS; Web Application Server)는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어입니다. 정적인 콘텐츠를 처리하는 것은 웹 서버(Web Server)입니다."
  },
  {
    "번호": 16,
    "문제": "다음 중 유스케이스 다이어그램(Use Case Diagram)의 구성 요소가 아닌 것은?",
    "선택지": {
      "①": "System",
      "②": "Actor",
      "③": "Operation",
      "④": "UseCase"
    },
    "정답": "③",
    "해설": "유스케이스 다이어그램은 시스템/시스템 범위, 액터, 유스케이스, 관계로 구성됩니다."
  },
  {
    "번호": 17,
    "문제": "폭포수 모형의 특징으로 거리가 먼 것은?",
    "선택지": {
      "①": "순차적인 접근방법을 이용한다.",
      "②": "나선형 모형의 단점을 보완하기 위한 모형이다.",
      "③": "단계적 정의와 산출물이 명확하다.",
      "④": "모형의 적용 경험과 성공사례가 많다."
    },
    "정답": "②",
    "해설": "폭포수 모형은 전통적인, 즉 초기 형태의 생명 주기 모형으로 나선형 모형보다 앞서 소개되었습니다."
  },
  {
    "번호": 18,
    "문제": "송수신 데이터의 처리 방식 중 대량의 데이터를 처리할 때 사용하는 방식은?",
    "선택지": {
      "①": "실시간 방식",
      "②": "분산 처리 방식",
      "③": "배치 방식",
      "④": "지연 처리 방식"
    },
    "정답": "③",
    "해설": "대량의 송·수신 데이터를 처리할 때 사용하는 방식은 배치 방식입니다."
  },
  {
    "번호": 19,
    "문제": "결합도(Coupling)에 대한 설명으로 틀린 것은?",
    "선택지": {
      "①": "데이터 결합도(Data Coupling)는 두 모듈이 매개 변수로 자료를 전달할 때 자료 구조 형태로 전달되어 이용될 때 데이터가 결합되어 있다고 한다.",
      "②": "내용 결합도(Content Coupling)는 하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때 두 모듈은 내용적으로 결합되어 있다고 한다.",
      "③": "공통 결합도(Common Coupling)는 두 모듈이 동일한 전역 데이터를 접근한다면 공통 결합되어 있다고 한다.",
      "④": "결합도(Coupling)는 두 모듈 간의 상호작용, 또는 의존도 정도를 나타내는 것이다."
    },
    "정답": "①",
    "해설": "데이터 결합도는 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도입니다. ①번은 스탬프 결합도에 대한 설명입니다."
  },
  {
    "번호": 20,
    "문제": "CASE(Computer Aided Software Engineering)의 주요 기능으로 옳지 않은 것은?",
    "선택지": {
      "①": "S/W 라이프 사이클 전 단계의 연결",
      "②": "그래픽 지원",
      "③": "다양한 소프트웨어 개발 모형 지원",
      "④": "언어 번역"
    },
    "정답": "④",
    "해설": "CASE의 주요 기능에는 소프트웨어 생명 주기 전 단계의 연결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원 등이 있습니다."
  },
  {
    "번호": 21,
    "문제": "테스트 하네스(Test Harness)의 구성 요소에 해당하지 않는 것은?",
    "선택지": {
      "①": "테스트 드라이버",
      "②": "테스트 스텁",
      "③": "테스트 케이스",
      "④": "테스트 시나리오"
    },
    "정답": "④",
    "해설": "테스트 하네스의 구성 요소에는 테스트 드라이버, 테스트 스텁, 테스트 슈트, 테스트 케이스, 테스트 스크립트, 목 오브젝트 등이 있습니다."
  },
  {
    "번호": 22,
    "문제": "통합 개발 환경(IDE)에 대한 설명으로 옳지 않은 것은?",
    "선택지": {
      "①": "개발을 위한 편집기, 컴파일러, 디버거 등이 포함되어 있다.",
      "②": "코드의 자동 생성이 가능하다.",
      "③": "다양한 기능들을 다운로드하여 추가할 수 있다.",
      "④": "단일 플랫폼만을 지원하는 한계가 있다."
    },
    "정답": "④",
    "해설": "통합 개발 환경(IDE)은 프로그램 별로 단일 플랫폼뿐만 아니라 멀티 플랫폼(=크로스 플랫폼)을 지원하기도 합니다."
  },
  {
    "번호": 23,
    "문제": "디지털 저작권 관리(DRM)에 대한 설명으로 가장 옳지 않은 것은?",
    "선택지": {
      "①": "콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술이다.",
      "②": "패키징 수행 전 라이선스 정보를 클리어링 하우스에 등록한다.",
      "③": "원본 콘텐츠가 아날로그인 경우에는 변환 작업을 수행한 뒤 패키징을 한다.",
      "④": "암호화, 식별 기술, 크랙 방지, 인증 등의 기술이 사용된다."
    },
    "정답": "②",
    "해설": "라이선스 정보는 패키징 수행 시 클리어링 하우스에 등록됩니다."
  },
  {
    "번호": 24,
    "문제": "스택에서 순서가 A, B, C, D로 정해진 입력 자료를, push → push → pop → push → pop → push → pop → pop으로 연산했을 때 출력은?",
    "선택지": {
      "①": "C, B, D, A",
      "②": "B, C, D, A",
      "③": "B, C, A, D",
      "④": "C, B, A, D"
    },
    "정답": "②",
    "해설": "PUSH는 스택에 자료를 입력하는 명령이고, POP은 스택에서 자료를 출력하는 명령입니다. 문제에 제시된 대로 PUSH와 POP을 수행하면 순서대로 B, C, D, A가 출력됩니다."
  },
  {
    "번호": 25,
    "문제": "EAI(Enterprise Application Integration)의 구축유형에 대한 설명으로 틀린 것은?",
    "선택지": {
      "①": "Point-to-Point는 가장 기본적인 애플리케이션 통합 방식으로, 애플리케이션을 1 : 1로 연결한다.",
      "②": "Hub&Spoke는 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식이다.",
      "③": "애플리케이션 사이에 미들웨어를 두어 처리하는 방식은 ESB이다.",
      "④": "Hybrid는 Point-to-Point와 Hub&Spoke의 혼합 방식이다."
    },
    "정답": "④",
    "해설": "Hybrid는 Hub&Spoke와 Message Bus의 혼합 방식입니다."
  },
  {
    "번호": 26,
    "문제": "디지털 저작권 관리(DRM)의 구성 요소에 대한 설명으로 틀린 것은?",
    "선택지": {
      "①": "클리어링 하우스는 저작권에 대한 권한 및 결제에 대해 관리한다.",
      "②": "패키저는 암호화된 콘텐츠를 배포한다.",
      "③": "DRM 컨트롤러는 배포된 콘텐츠를 통제한다.",
      "④": "보안 컨테이너는 콘텐츠 유통을 위한 전자적 보안장치이다."
    },
    "정답": "②",
    "해설": "암호화된 콘텐츠를 배포하는 것은 콘텐츠 분배자가 수행하며, 패키저는 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램입니다."
  },
  {
    "번호": 27,
    "문제": "테스트 오라클(Test Oracle)에 대한 설명으로 틀린 것은?",
    "선택지": {
      "①": "테스트 오라클을 모든 테스트 케이스에 적용할 수 있다.",
      "②": "애플리케이션의 변경이 있을 때는 일관 검사 오라클을 이용하는 것이 효과적이다.",
      "③": "테스트 오라클의 값을 수학적 기법을 이용하여 구할 수 있다.",
      "④": "테스트 대상 프로그램의 실행, 결과 비교, 커버리지 측정 등을 자동화할 수 있다."
    },
    "정답": "①",
    "해설": "테스트 오라클을 모든 테스트 케이스에 적용할 수 없습니다."
  },
  {
    "번호": 28,
    "문제": "버블 정렬을 이용한 오름차순 정렬 시 다음 자료에 대한 2회전 후의 결과는?\n\n9, 6, 7, 3, 5",
    "선택지": {
      "①": "3, 5, 6, 7, 9",
      "②": "6, 7, 3, 5, 9",
      "③": "3, 5, 9, 6, 7",
      "④": "6, 3, 5, 7, 9"
    },
    "정답": "④",
    "해설": "버블 정렬은 인접한 두 개의 레코드 키 값을 비교하여 교환하는 방식입니다. 2회전 후의 결과는 6, 3, 5, 7, 9입니다."
  },
  {
    "번호": 29,
    "문제": "형상 관리 도구의 주요 기능으로 거리가 먼 것은?",
    "선택지": {
      "①": "체크아웃(Check-out)",
      "②": "체크인(Check-in)",
      "③": "식별(Identification)",
      "④": "커밋(Commit)"
    },
    "정답": "③",
    "해설": "형상 관리 도구의 주요 기능에는 동기화, 체크인/체크아웃, 가져오기, 커밋, 저장소 등이 있습니다."
  },
  {
    "번호": 30,
    "문제": "목적에 따른 테스트 방식 중 시스템에 과도한 정보량이나 빈도 등을 부과하여 과부하 시에도 소프트웨어가 정상적으로 실행되는지를 확인하는 테스트는?",
    "선택지": {
      "①": "회복(Recovery) 테스트",
      "②": "강도(Stress) 테스트",
      "③": "성능(Performance) 테스트",
      "④": "회귀(Regression) 테스트"
    },
    "정답": "②",
    "해설": "강도(Stress) 테스트는 시스템이 과부하 상태에서도 정상적으로 동작하는지를 확인하는 테스트입니다."
  },
  {
    "번호": 31,
    "문제": "빌드 자동화 도구에 대한 설명으로 틀린 것은?",
    "선택지": {
      "①": "Gradle은 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행한다.",
      "②": "Ant는 Groovy를 기반으로 한 오픈소스로 안드로이드 앱 개발 환경에서 사용된다.",
      "③": "빌드 자동화 도구에는 Ant, Gradle, Jenkins 등이 있다.",
      "④": "빌드 자동화 도구는 지속적인 통합개발환경에서 유용하게 활용된다."
    },
    "정답": "②",
    "해설": "Ant는 XML 기반의 빌드 도구로, Groovy를 기반으로 하는 것은 Gradle입니다."
  },
  {
    "번호": 32,
    "문제": "해싱 함수(Hashing Function)의 종류가 아닌 것은?",
    "선택지": {
      "①": "제곱법(mid-square)",
      "②": "제산법(division)",
      "③": "숫자분석법(digit analysis)",
      "④": "개방주소법(open addressing)"
    },
    "정답": "④",
    "해설": "해싱 함수의 종류에는 제산법, 제곱법, 폴딩법, 기수 변환법, 계수 분석법(숫자 분석법) 등이 있습니다. 개방 주소법은 충돌 해결 기법입니다."
  },
  {
    "번호": 33,
    "문제": "효과적인 모듈 설계를 위한 유의사항으로 거리가 먼 것은?",
    "선택지": {
      "①": "모듈 간의 결합도를 약하게 하면 모듈 독립성이 향상된다.",
      "②": "하나의 입구와 하나의 출구를 갖도록 해야 한다.",
      "③": "모듈의 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안 된다.",
      "④": "일관성을 줄이고 중복성을 유지시킨다."
    },
    "정답": "④",
    "해설": "효과적인 모듈 설계를 위해서는 중복성을 줄이고 일관성을 유지시켜야 합니다."
  },
  {
    "번호": 34,
    "문제": "White Box Testing에 대한 설명으로 옳지 않은 것은?",
    "선택지": {
      "①": "Base Path Testing, Boundary Value Analysis가 대표적인 기법이다.",
      "②": "Source Code의 모든 문장을 한 번 이상 수행함으로써 진행된다.",
      "③": "모듈 안의 작동을 직접 관찰할 수 있다.",
      "④": "산출물의 각 기능별로 적절한 프로그램의 제어 구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한다."
    },
    "정답": "①",
    "해설": "경계값 분석(Boundary Value Analysis)은 블랙박스 테스트 기법입니다."
  },
  {
    "번호": 35,
    "문제": "워크스루(Walkthrough)와 인스펙션(Inspection)에 대한 설명으로 가장 옳지 않은 것은?",
    "선택지": {
      "①": "워크스루는 전문가들에 의해 개발자의 작업 내역이 검토된다.",
      "②": "워크스루는 제품 개발자가 주최가 된다.",
      "③": "워크스루는 오류 발견과 발견된 오류의 문제 해결에 중점을 둔다.",
      "④": "인스펙션은 워크스루를 발전시킨 형태이다."
    },
    "정답": "③",
    "해설": "워크스루의 목적은 오류 해결이 아니라 오류의 조기 검출입니다."
  },
  {
    "번호": 36,
    "문제": "중위 표기법(Infix)의 수식 ( A + B ) * C + ( D + E )을 후위 표기법(Postfix)으로 옳게 표기한 것은?",
    "선택지": {
      "①": "AB + CDE * + +",
      "②": "AB + C*DE + +",
      "③": "+ AB*C + DE +",
      "④": "+ * + ABC + DE"
    },
    "정답": "②",
    "해설": "후위 표기 방식은 연산자를 해당 피연산자 두 개의 뒤로 이동시키는 방식입니다. 주어진 수식의 후위 표기법 변환 결과는 AB + C*DE + + 입니다."
  },
  {
    "번호": 37,
    "문제": "다음 설명의 소프트웨어 버전 관리 도구 방식은?\n\nㆍ버전 관리 자료가 원격 저장소와 로컬 저장소에 함께 저장되어 관리된다.\nㆍ로컬 저장소에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업할 수 있다.\nㆍ대표적인 버전 관리 도구로 Git이 있다.",
    "선택지": {
      "①": "단일 저장소 방식",
      "②": "분산 저장소 방식",
      "③": "공유 폴더 방식",
      "④": "클라이언트·서버 방식"
    },
    "정답": "②",
    "해설": "버전 관리 자료가 원격 저장소와 로컬 저장소에 함께 저장되어 관리되는 방식은 분산 저장소 방식입니다."
  },
  {
    "번호": 38,
    "문제": "위험 모니터링의 의미로 옳은 것은?",
    "선택지": {
      "①": "위험을 이해하는 것",
      "②": "첫 번째 조치로 위험을 피할 수 있도록 하는 것",
      "③": "위험 발생 후 즉시 조치하는 것",
      "④": "위험 요소 징후들에 대하여 계속적으로 인지하는 것"
    },
    "정답": "④",
    "해설": "위험 감시(Risk Monitoring)는 위험 요소 징후들에 대해 계속적으로 인지하는 것을 의미합니다."
  },
  {
    "번호": 39,
    "문제": "n개의 노드로 구성된 무방향 그래프의 최대 간선 수는?",
    "선택지": {
      "①": "n－1",
      "②": "n/2",
      "③": "n(n－1)/2",
      "④": "n(n＋1)"
    },
    "정답": "③",
    "해설": "n개의 정점으로 구성된 무방향 그래프에서 최대 간선 수는 n(n-1)/2입니다."
  },
  {
    "번호": 40,
    "문제": "이진 검색 알고리즘에 대한 설명으로 틀린 것은?",
    "선택지": {
      "①": "탐색 효율이 좋고 탐색 시간이 적게 소요된다.",
      "②": "검색할 데이터가 정렬되어 있어야 한다.",
      "③": "피보나치 수열에 따라 다음에 비교할 대상을 선정하여 검색한다.",
      "④": "비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다."
    },
    "정답": "③",
    "해설": "이진 검색과 피보나치 수열은 아무런 관계가 없습니다."
  },
  {
    "번호": 41,
    "문제": "데이터 모델의 구성 요소가 아닌 것은?",
    "선택지": {
      "①": "속성(Attribute)",
      "②": "연산(Operation)",
      "③": "관계(Relationship)",
      "④": "개체(Entity)"
    },
    "정답": "②",
    "해설": "데이터 모델의 구성 요소에는 개체(Entity), 속성(Attribute), 관계(Relationship)이 있으며, 연산(Operation)은 포함되지 않습니다."
  },
  {
    "번호": 42,
    "문제": "시스템 카탈로그(System Catalog)에 대한 설명으로 옳지 않은 것은?",
    "선택지": {
      "①": "사용자, 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블이다.",
      "②": "일반 이용자도 SQL을 이용하여 내용을 검색하거나 수정할 수 있다.",
      "③": "DBMS가 스스로 생성하고 유지한다.",
      "④": "데이터 디렉터리, 번역기, 질의 최적화기 등으로 구성된다."
    },
    "정답": "②",
    "해설": "시스템 카탈로그는 일반 이용자가 SQL을 통해 검색할 수는 있지만, 삽입·수정·삭제 작업은 허용되지 않습니다."
  },
  {
    "번호": 43,
    "문제": "관계대수에 대한 설명으로 옳지 않은 것은?",
    "선택지": {
      "①": "원하는 릴레이션을 정의하는 방법을 제공하며 비절차적 언어이다.",
      "②": "릴레이션 조작을 위한 연산의 집합으로 피연산자와 결과가 모두 릴레이션이다.",
      "③": "일반 집합 연산과 순수 관계 연산으로 구분된다.",
      "④": "질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다."
    },
    "정답": "④",
    "해설": "관계대수는 원하는 릴레이션을 정의하는 방법을 제공하는 것이 맞지만, 절차적인 특징을 가지고 있습니다. 원하는 정보가 무엇인지 정의하는 비절차적인 특성을 가지는 것은 관계해석입니다."
  },
  {
    "번호": 44,
    "문제": "DML에 해당하는 것으로만 나열된 것은?",
    "선택지": {
      "①": "SELECT, UPDATE, INSERT",
      "②": "SELECT, UPDATE, GRANT",
      "③": "SELECT, INSERT, GRANT",
      "④": "SELECT, UPDATE, INSERT, GRANT"
    },
    "정답": "①",
    "해설": "SELECT, UPDATE, INSERT는 DML(데이터 조작 언어)에 해당하며, GRANT는 DCL(데이터 제어 언어)입니다."
  },
  {
    "번호": 45,
    "문제": "개체-관계 모델에 대한 설명으로 옳지 않은 것은?",
    "선택지": {
      "①": "오너-멤버(Owner-Member) 관계라고도 한다.",
      "②": "개체 타입과 이들 간의 관계 타입을 기본 요소로 이용하여 현실 세계를 개념적으로 표현한다.",
      "③": "E-R 다이어그램에서 개체 타입은 사각형으로 나타낸다.",
      "④": "E-R 다이어그램에서 속성은 타원으로 나타낸다."
    },
    "정답": "①",
    "해설": "오너-멤버(Owner-Member) 관계라고도 불리는 데이터 모델은 네트워크(망)형 데이터 모델이며, 개체-관계(E-R) 모델이 아닙니다."
  },
  {
    "번호": 46,
    "문제": "릴레이션 R1에 속한 애트리뷰트의 조합인 외래키를 변경하려면 이를 참조하고 있는 R2의 릴레이션의 기본키도 변경해야 하는데 이를 무엇이라고 하는가?",
    "선택지": {
      "①": "정보 무결성",
      "②": "고유 무결성",
      "③": "키 제약성",
      "④": "참조 무결성"
    },
    "정답": "④",
    "해설": "참조 무결성(Referential Integrity)은 외래키 값이 NULL이거나 참조하는 릴레이션의 기본키 값과 동일해야 한다는 규정입니다."
  },
  {
    "번호": 47,
    "문제": "아래 그림에서 트리의 차수(degree)를 구하면?",
    "선택지": {
      "①": "2",
      "②": "3",
      "③": "4",
      "④": "5"
    },
    "정답": "②",
    "해설": "트리(Tree)에서 차수(Degree)는 가장 차수가 많은 노드의 차수입니다. 문제에 주어진 트리에서 각 노드의 차수를 비교했을 때 최대 차수는 3입니다."
  },
  {
    "번호": 48,
    "문제": "정규화 과정 중 1NF에서 2NF가 되기 위한 조건은?",
    "선택지": {
      "①": "1NF를 만족하고 모든 도메인이 원자 값이어야 한다.",
      "②": "1NF를 만족하고 키가 아닌 모든 애트리뷰트들이 기본 키에 이행적으로 함수 종속되지 않아야 한다.",
      "③": "1NF를 만족하고 다치 종속이 제거되어야 한다.",
      "④": "1NF를 만족하고 키가 아닌 모든 속성이 기본키에 완전 함수적 종속되어야 한다."
    },
    "정답": "④",
    "해설": "1NF에서 2NF가 되려면 1NF를 만족하고 키가 아닌 모든 속성이 기본키에 완전 함수적으로 종속되어야 합니다."
  },
  {
    "번호": 49,
    "문제": "병행제어 기법 중 로킹에 대한 설명으로 옳지 않은 것은?",
    "선택지": {
      "①": "로킹의 대상이 되는 객체의 크기를 로킹 단위라고 한다.",
      "②": "데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.",
      "③": "로킹의 단위가 작아지면 로킹 오버헤드가 증가한다.",
      "④": "로킹의 단위가 커지면 데이터베이스 공유도가 증가한다."
    },
    "정답": "④",
    "해설": "로킹의 단위가 커지면 병행성 수준이 낮아져 데이터베이스 공유도가 감소합니다."
  },
  {
    "번호": 50,
    "문제": "다음 중 파티션에 대한 설명으로 틀린 것은?",
    "선택지": {
      "①": "파티셔닝으로 인해 쿼리 성능은 향상되지만, 백업 및 복구 속도는 느려진다.",
      "②": "파티셔닝된 테이블은 물리적으로 별도의 세그먼트에 저장된다.",
      "③": "파티션은 하나의 테이블을 작은 논리적 단위로 나눈 것이다.",
      "④": "파티셔닝을 수행하면 데이터 가용성이 향상된다."
    },
    "정답": "①",
    "해설": "파티셔닝을 수행하면 데이터가 분산 저장되므로 백업 및 복구 속도가 향상됩니다."
  },
  {
    "번호": 51,
    "문제": "다음 SQL 문에서 괄호 안에 들어갈 내용으로 옳은 것은?\n\nUPDATE MEMBER ( ) GRADE = ‘GOLD’ WHERE POINT >= 1000;",
    "선택지": {
      "①": "SET",
      "②": "FROM",
      "③": "INTO",
      "④": "IN"
    },
    "정답": "①",
    "해설": "UPDATE 문에서 특정 열을 수정할 때는 SET 키워드를 사용합니다. 따라서 괄호 안에는 'SET'이 들어가야 합니다."
  },
  {
    "번호": 52,
    "문제": "분산 데이터베이스 목표 중 “데이터베이스의 분산된 물리적 환경에서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장된다.”는 것과 관계있는 것은?",
    "선택지": {
      "①": "장애 투명성",
      "②": "병행 투명성",
      "③": "위치 투명성",
      "④": "중복 투명성"
    },
    "정답": "①",
    "해설": "장애 투명성(Failure Transparency)은 네트워크 장애나 특정 노드의 오류가 발생해도 데이터 무결성이 유지되는 것을 의미합니다."
  },
  {
    "번호": 53,
    "문제": "데이터베이스 설계 단계와 그 단계에서 수행되는 작업의 연결이 잘못된 것은?",
    "선택지": {
      "①": "요구 조건 분석 - 트랜잭션 모델링",
      "②": "물리적 설계 단계 - 목표 DBMS에 맞는 물리적 구조 설계",
      "③": "논리적 설계 단계 - 목표 DBMS에 종속적인 논리 스키마 설계",
      "④": "구현 단계 - 목표 DBMS DDL로 스키마 작성"
    },
    "정답": "①",
    "해설": "트랜잭션 모델링은 개념적 설계 단계에서 수행하는 작업이며, 요구 조건 분석 단계에서는 사용자 요구사항을 수집 및 분석합니다."
  },
  {
    "번호": 54,
    "문제": "다음 질의어를 SQL 문장으로 바르게 나타낸 것은? (단, 사원 테이블에 사원코드, 이름, 부서의 열이 있다고 가정한다.)\n\n부서가 인사, 사원코드가 3000이하인 사원의 사원코드에 1000을 더하라.",
    "선택지": {
      "①": "UPDATE 사원코드 SET 사원코드+1000 WHERE 부서=“인사” OR 사원코드<=3000;",
      "②": "UPDATE 사원 SET 사원코드=사원코드+1000 WHERE 부서=“인사” OR 사원코드<=3000;",
      "③": "UPDATE 사원코드 SET 사원코드+1000 WHERE 부서=“인사” AND 사원코드<=3000;",
      "④": "UPDATE 사원 SET 사원코드=사원코드+1000 WHERE 부서=“인사” AND 사원코드<=3000;"
    },
    "정답": "④",
    "해설": "UPDATE 문법을 올바르게 적용해야 하며, SET 키워드를 사용하여 사원코드를 갱신합니다. 또한, 조건을 정확하게 만족시키기 위해 'AND'를 사용해야 합니다."
  },
  {
    "번호": 55,
    "문제": "분산 데이터베이스의 장점으로 거리가 먼 것은?",
    "선택지": {
      "①": "지역 자치성이 높다.",
      "②": "잠재적 오류가 감소한다.",
      "③": "분산 제어가 가능하다.",
      "④": "효용성과 융통성이 높다."
    },
    "정답": "②",
    "해설": "분산 데이터베이스는 여러 장소에 데이터를 저장하여 지역 자치성과 융통성이 높지만, 관리가 복잡해지고 잠재적 오류가 증가하는 단점이 있습니다."
  }
]